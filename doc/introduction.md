# Introducci√≥n a Django REST Framework

El uso de herramientas cada vez m√°s especializadas en la construcci√≥n
de interfaces gr√°ficas contin√∫a en aumento y la necesidad de construir
APIs que puedan alimentarlas crece junto con ellas. Ya sea que desees
construir un API para alimentar a un cliente o para exponer funcionalidad
a otros servicios a trav√©s de la red, si tu objetivo es crear un servicio
RESTful y quieres utilizar Django, la opci√≥n inevitable es usar **Django REST
Framework**.

Django REST Framework es un conjunto de clases y utilidades que siguen
la filosof√≠a de Django de modularidad y baja cohesi√≥n que te permitir√°n
crear el API que necesitas con muy poco esfuerzo y alta personalizaci√≥n.

Django REST framework puede ser incluido a cualquier proyecto con un simple
`pip install djangorestframework` y la correspondiente instalaci√≥n
de `'rest_framework'` en `INSTALLED_APPS`

## Request y Reponse

Si bien Django ya incluye dos clases muy potentes para manejar las peticiones
y las respuestas (`HttpRequest` y `HttpResponse`), Django REST Framework (DRF) no
se queda atr√°s y extiende esta funcionalidad exponiendo sus propias clases `Request`
y `Response` que facilitan todav√≠a m√°s el manejo de datos y la salida a m√∫ltiples
formatos utilizando los famos√≠simos `Renderers` de *DRF*, pero vayamos directo a un
ejemplo:

El siguiente c√≥digo:
```python
# users.views

from django.contrib.auth.models import User
from django.http import HttpResponse, JsonResponse


def list_users(request):
    if request.method == 'GET':
        users = User.objects.all()
        data = []
        for user in users:
            data.append({
                'id': user.pk,
                'username': user.username,
                'email': user.email,
                'first_name': user.first_name,
                'last_name': user.last_name
            })
        return JsonResponse(data, safe=False)
    else:
        return HttpResponse('Method not allowed', status_code=405)
```

puede ser f√°cilmente traducido a:

```python
# users.views

from django.contrib.auth.models import User
from rest_framework.decorators import api_view
from rest_framework.response import Response


@api_view(['GET'])
def list_users(request):
    users = User.objects.all()
    data = []
    for user in users:
        data.append({
            'id': user.pk,
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name
        })
    return Response(data)
```

Donde `request` es una instancia de la clase **Request** de DRF.

## Serializers

Otro concepto muy fuerte de *DRF* son sus **`Serializers`**. Los serializers
permiten convertir tipos de datos complejos como *Querysets* e *instancias de clases*
a datos nativos de Python a trav√©s de una serie de validaciones sucesivias. Al igual
que con los *Requests*, hag√°mos una prueba.

Suponiendo que tenemos la siguiente clase:

```python
class Airplane(object):

    def __init__(self, model, year, fuel_consumption):
        self.model = model
        self.year = year
        self.fuel_consumption = fuel_consumption
```

Y el siguiente serializer:

```python
from rest_framework import serializers

class AirplaneSerializer(serializers.Serializer):

    model = serializers.CharField()
    year = serializers.IntegerField(min_value=1970, max_value=2019)
    fuel_consumption = serializers.FloatField()
```

Entonces podr√≠amos realizar el siguiente tipo de operaciones:
```python
boeing = Airplane('Boeign', 1980, 34.3)
boeign_serializer = AirplaneSerializer(boeing)
boeign_serializer.data
>>> {'model': 'Boeing', 'year': 1980, 'fuel_consumption': 34.3}
```

## Model serializers ü§Ø

Cuando ya tenemos la estructura de los datos definida, es decir, cuando ya tenemos
un modelo que tiene los detalles necesarios de nuestra esquema, no necesitamos
crear un serializer que repita esos mismos detalles dentro de su especificaci√≥n ya
que *DRF* provee una clase especial que se llama **`ModelSerializer`** y es capaz
de leer la definici√≥n del modelo y utilizarla dentro de sus validaciones. Por ejemplo:

Dado el modelo de **Repositorio**:
```python
# repositories.models

from django.db import models


class Repository(models.Model):

    name = models.CharField(max_length=50, unique=True)
    owner = models.CharField(max_length=50, help_text="Owner's username")
    url = models.URLField()
    followers = models.PositiveIntegerField(default=0)
```

Podemos definir un serializer de la siguiente manera:
```python
# repositories.serializers

from rest_framework import serializers
from repositories.models import Repository


class RespositoryModelSerializer(serializers.ModelSerializer):

    class Meta:
        model = Repository
        fields = ('id', 'name', 'owner', 'url', 'followers')
        read_only_fields = ('id',)
```

Y finalmente tener una sola vista que pueda manejar la creaci√≥n y listado
de una manera muy clara:

```python
# repositories.views

from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response

from repositories.serializers import RespositoryModelSerializer
from repositories.models import Repository


@api_view(['GET', 'POST'])
def list_create_users(request):
    if request.method == 'POST':
        serializer = RespositoryModelSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    else:  # HTTP method is GET
        queryset = Repository.objects.all()
        serializer = RespositoryModelSerializer(queryset, many=True)
        return Response(serializer.data)

```

Lo cual, junto con la URL correcta podr√≠a darnos las siguientes funcionalidades:

* Creaci√≥n de repositorios a trav√©s del m√©todo POST a la URL `/repositories/`
* Listado de repositorios a trav√©s del m√©todo GET a la URL `/repositories/`

Resultado:
```http
GET /repositories/ HTTP/1.1
Accept: */*
...


HTTP/1.1 200 OK
Allow: GET, OPTIONS
Content-Type: application/json
...

[
    {
        "id": 1,
        "name": "cookiecutter-django",
        "owner": "pydanny"
        "url": "http://github.com/pydanny/cookiecutter-django",
        "followers": 5922
    },
    {
        "id": 2,
        "name": "pyjwt"
        "owner": "jpadilla"
        "url": "https://github.com/jpadilla/pyjwt",
        "followers": 923
    }
    ...
]
```

Y

```http
POST /repositories/ HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
...

{
    "name": "cride-platzi",
    "owner": "pablotrinidad",
    "url": "http://github.com/pablotrinidad/cride-platzi",
    "followers": 45
}

HTTP/1.1 200 Created
Content-Type: application/json
...

{
    "id": 3,
    "name": "cride-platzi",
    "owner": "pablotrinidad",
    "url": "http://github.com/pablotrinidad/cride-platzi",
    "followers": 45
}

```

## Class-based views

Pero... ¬øqui√©n realmente usa vistas basadas en funciones estos d√≠as? Habiendo
tantas herrramientas dentro de las clases de Django, no usar herencia de clases
en nuestro proyecto deber√≠a casi ser considerado una mala pr√°ctica üòÖ.

¬øRecuerdas la clase **`View`** que tiene Django que nos permite tener vistas basadas
en clases? Bueno, DRF tiene la suya y de hecho hereda de **`View`**, se llama **`APIView`**.

El c√≥digo anterior lo podemos traducir a los siguiente:

```python
# repositories.views

from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView

from repositories.serializers import RespositoryModelSerializer
from repositories.models import Repository


class ListCreateUsersAPIView(APIView):

    def post(self, request):
        """Handle HTTP POST method."""
        serializer = RespositoryModelSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def get(self, request):
        """Handle HTTP GET method."""
        queryset = Repository.objects.all()
        serializer = RespositoryModelSerializer(queryset, many=True)
        return Response(serializer.data)
```

## ¬øNo es suficiente? ü§î

¬øA√∫n no te convence? Bueno, as√≠ como Django tiene sus propios mixins que nos
permiten tener vistas para realizar tareas gen√©ricas, DRF tienes las suyas.
El c√≥digo anterior todav√≠a puede ser reducido a lo siguiente:

```python

# repositories.views

from rest_framework.generics import ListCreateAPIView

from repositories.serializers import RespositoryModelSerializer
from repositories.models import Repository


class ListCreateUsersAPIView(ListCreateAPIView):

    queryset = Repository.objects.all()
    serializer_class = RespositoryModelSerializer
```

## Conclusi√≥n

En fin, Django REST Framework adquiere su nombre por la incre√≠ble cantidad
de clases, funciones y herramientas que nos permiten controlar todas las parter
del proceso de construcci√≥n de un API. Algo que particularmente me gusta mucho
es que el c√≥digo fuente del proyecto tambi√©n puede funcionar como una muy buena gu√≠a
si tu objetivo es crear mixins y clases m√°s espec√≠ficas.

En el curso avanzado de Django exploramos todos los rincones de DRF. Validaremos
serializers, crearemos rutas customizadas, paginaremos nuestros endpoints, incluiremos b√∫squeda
y filtrado, crearemos nuestros propios permisos y trabajaremos con los m√©todos de autenticaci√≥n.
